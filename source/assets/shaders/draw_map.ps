#version 450
#extension GL_ARB_shading_language_420pack: enable

layout(location = 0) noperspective in vec2 attr_uv;
layout(location = 0) out vec4 out_pixel0;
layout(binding=0) uniform sampler2D tex_base;
layout(binding=1) uniform sampler2D tex_environment;
layout(binding=2) uniform sampler2D tex_pixelColorLookup;

layout(binding = 0) uniform uf_data
{
	float uf_time;
};

float rand(vec2 n) {
    return fract(cos(dot(n, vec2(5.9898, 4.1414))) * 65899.89956);
}

float noise( in vec2 n )
{
    const vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}

float fbm(vec2 n) {
    float total = 0.0;
    float amplitude = 1.0;
    for (int i = 0; i < 4; i++){
        total += noise(n) * amplitude;
        n += n;
        amplitude *= 0.51;
    }
    return total;
}

vec3 CalculateLavaPixelColor(vec2 uv)
{
     vec3 col1 = vec3(0.5, 0.0, 0.1);
     vec3 col2 = vec3(0.9, 0.3, 0.1);
     vec3 col3 = vec3(0.0, 0.0, 0.0);
     vec3 col4 = vec3(1.0, 0.9, 0.6);
     vec3 col5 = vec3(0.1, 0.4, 0.8);
     vec3 col6 = vec3(1.155);

    vec2 speed = vec2(0.35, 0.35);

    vec2 nfbm = vec2( uv.x, uv.y - rand(vec2(1., 5.)));
    float q = fbm(nfbm);
    vec2 arg1 = vec2(uv + q +  uf_time * speed.x -uv.x -uv.y);
    vec2 arg2 = vec2 (uv + q - rand(vec2(100., 100.)) * speed.y);
    vec2 r = vec2(fbm(arg1 ), fbm(arg2));

    vec2 agr3 = vec2(uv + r);
    vec3 c = mix(col1, col2, fbm(agr3)) + mix(col3, col4, r.x) - mix(col5, col6, r.y);
    return c;
}

vec3 CalculateLavaGlowColor()
{
	float iTime = uf_time * 0.001 + 1000.0;
	vec2 u = attr_uv.xy * 3.3;

	// borrowed from https://www.shadertoy.com/view/DdyGDD
    vec2  R = vec2(0.,sin(iTime/25.0)*8.24),
          p = 5.*( u+u+vec2(800.,cos((iTime+5.)/10.0)*4000.) - R ) / R.y,
          r = p-p;
    
    for(float f=1.; f < 40.; f *= 1.05 )	
		r += sin( p*f +iTime*0.85) / f,
        p = p * mat2(8,6,-8,6)*.1 + r*.4;

    float l = length(r);
    return vec3(l*0.29, l*l*0.024, l*l*l*0.0016);
}

void main()
{
	//ivec2 pixelMapSize = textureSize(tex_base, 0);
	//vec2 pixelMapPixelSize = vec2(1.0) / vec2(pixelMapSize);

	vec4 envSample = texture(tex_environment, attr_uv).rgba;
	// env:
	// r -> lavaGlowIntensity
	// b -> pixelObstructionFactor (1.0 means not obstructed)

	vec2 pixelMapSample = texture(tex_base, attr_uv).rg;
	int pixelType = int(pixelMapSample.r * 255.0f + 0.5);	
	int pixelSeed = int(pixelMapSample.g * 255.0f + 0.5);
	bool isSolid = pixelType != 0; // check for smoke too?

	vec4 pixelColor = texelFetch(tex_pixelColorLookup, ivec2(pixelSeed, pixelType), 0);
	
	pixelColor.a = isSolid ? 1.0 : 0.0;
	if(pixelType == 4)
	{
		// lava color is dynamic
		pixelColor.rgb = (CalculateLavaPixelColor(attr_uv*7.5 * 5.0) * 0.5 + pixelColor.rgb*0.8) ;// + CalculateLavaGlowColor()*0.5;
	}
	
	
	pixelColor.rgb *= envSample.g;
	// lava glow
	if(!isSolid && envSample.r > 0.001)
	{
		pixelColor.rgb = vec3(236.0/255.0, 50.0/255.0, 0.0);//CalculateLavaGlowColor();//vec3(236.0/255.0, 50.0/255.0, 0.0);
		pixelColor.a = envSample.r;
	}
	
	out_pixel0 = pixelColor;
}
